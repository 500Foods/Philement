#!/bin/bash

# Script: analyze-gcov-coverage.sh
# Purpose: Analyze gcov files to show detailed line-by-line coverage statistics
# Usage: ./analyze-gcov-coverage.sh
# 
# This script analyzes gcov files generated by Test 11 Unity tests and provides
# detailed coverage information focusing on the Unity test coverage data.

# Get script directory and project paths
SCRIPT_DIR
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
BUILD_DIR="$PROJECT_ROOT/build/unity/src"
COVERAGE_BUILD_DIR="$PROJECT_ROOT/build/coverage/src"

# Load .trial-ignore patterns for consistent filtering
TRIAL_IGNORE_PATTERNS=()
if [[ -f "$PROJECT_ROOT/.trial-ignore" ]]; then
    while IFS= read -r line; do
        # Skip comments and empty lines
        if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]; then
            continue
        fi
        # Remove leading ./ if present and add pattern
        pattern="${line#./}"
        TRIAL_IGNORE_PATTERNS+=("$pattern")
    done < "$PROJECT_ROOT/.trial-ignore"
fi

# Function to check if a file should be ignored based on .trial-ignore
should_ignore_file() {
    local filename="$1"
    
    for pattern in "${TRIAL_IGNORE_PATTERNS[@]}"; do
        if [[ "$filename" == *"$pattern"* ]]; then
            return 0  # Should ignore
        fi
    done
    
    return 1  # Should not ignore
}

# Associative arrays to store coverage data from both directories
declare -A unity_covered_lines
declare -A unity_instrumented_lines
declare -A coverage_covered_lines
declare -A coverage_instrumented_lines
declare -A all_files

# Function to analyze a single gcov file and store data
analyze_gcov_file() {
    local gcov_file="$1"
    local coverage_type="$2"  # "unity" or "coverage"
    local covered_lines=0
    local instrumented_lines=0
    
    # Parse the gcov file
    while IFS= read -r line; do
        # Skip metadata lines (starting with spaces and dash)
        if [[ "$line" =~ ^[[:space:]]*-:[[:space:]]*[0-9]+: ]]; then
            continue
        fi
        
        # Count covered lines (lines with execution count)
        if [[ "$line" =~ ^[[:space:]]*[0-9]+:[[:space:]]*[0-9]+: ]]; then
            ((covered_lines++))
            ((instrumented_lines++))
        # Count uncovered but instrumented lines
        elif [[ "$line" =~ ^[[:space:]]*#####:[[:space:]]*[0-9]+: ]]; then
            ((instrumented_lines++))
        fi
    done < "$gcov_file"
    
    # Skip files with no instrumented lines
    if [ "$instrumented_lines" -eq 0 ]; then
        return
    fi
    
    # Clean up the path for display - show as src/filename
    local filename_only
    filename_only=$(basename "$gcov_file" .gcov)
    local display_path="src/$filename_only"
    
    # Store data in appropriate arrays
    all_files["$display_path"]=1
    if [[ "$coverage_type" == "unity" ]]; then
        unity_covered_lines["$display_path"]=$covered_lines
        unity_instrumented_lines["$display_path"]=$instrumented_lines
    else
        coverage_covered_lines["$display_path"]=$covered_lines
        coverage_instrumented_lines["$display_path"]=$instrumented_lines
    fi
}

# Print header
echo "GCOV Coverage Analysis Report"
echo "Generated: $(date)"
echo "Project: $(basename "$PROJECT_ROOT")"
echo ""
echo "Coverage statistics from Unity test and general coverage gcov files"
echo ""
printf "%-37s %10s %12s %10s %10s %12s %10s\n" "File Path" "Unity Cov" "Unity Instr" "Unity %" "Cov Cov" "Cov Instr" "Cov %"
printf "%-37s %10s %12s %10s %10s %12s %10s\n" "$(printf '%0.s-' {1..37})" "$(printf '%0.s-' {1..10})" "$(printf '%0.s-' {1..12})" "$(printf '%0.s-' {1..10})" "$(printf '%0.s-' {1..10})" "$(printf '%0.s-' {1..12})" "$(printf '%0.s-' {1..10})"

# Find and analyze gcov files from both build directories
gcov_files_found=0

# Function to collect and process gcov files from a directory
collect_gcov_files() {
    local build_dir="$1"
    local coverage_type="$2"
    local files_found=0
    
    declare -a valid_gcov_files=()
    
    if [ -d "$build_dir" ]; then
        while IFS= read -r -d '' gcov_file; do
            # Extract the source filename from the gcov file
            filename=$(basename "$gcov_file" .gcov)
            
            # Skip external libraries and test framework files
            if [[ "$filename" == "unity.c" ]] || \
               [[ "$filename" == "jansson"* ]] || \
               [[ "$filename" == "test_"* ]] || \
               [[ "$gcov_file" == *"/usr/include/"* ]]; then
                continue
            fi
            
            # Skip files that should be ignored based on .trial-ignore
            if should_ignore_file "$filename"; then
                continue
            fi
            
            valid_gcov_files+=("$gcov_file")
        done < <(find "$build_dir" -name "*.gcov" -type f -print0 2>/dev/null)
        
        # Sort the valid gcov files by filename and process them
        mapfile -t sorted_files < <(printf '%s\n' "${valid_gcov_files[@]}" | sort)
        
        for gcov_file in "${sorted_files[@]}"; do
            analyze_gcov_file "$gcov_file" "$coverage_type"
            ((files_found++))
        done
    fi
    
    echo "$files_found"
}

# Collect data from Unity build directory
unity_files=$(collect_gcov_files "$BUILD_DIR" "unity")
gcov_files_found=$((gcov_files_found + "$unity_files"))

# Collect data from Coverage build directory
coverage_files=$(collect_gcov_files "$COVERAGE_BUILD_DIR" "coverage")
gcov_files_found=$((gcov_files_found + "$coverage_files"))

# Now display the combined table
for file_path in $(printf '%s\n' "${!all_files[@]}" | sort); do
    # Get Unity data
    u_covered=${unity_covered_lines["$file_path"]:-0}
    u_instrumented=${unity_instrumented_lines["$file_path"]:-0}
    u_percentage="0.000"
    if [ "$u_instrumented" -gt 0 ]; then
        u_percentage=$(awk "BEGIN {printf \"%.3f\", ($u_covered / $u_instrumented) * 100}")
    fi
    
    # Get Coverage data
    c_covered=${coverage_covered_lines["$file_path"]:-0}
    c_instrumented=${coverage_instrumented_lines["$file_path"]:-0}
    c_percentage="0.000"
    if [ "$c_instrumented" -gt 0 ]; then
        c_percentage=$(awk "BEGIN {printf \"%.3f\", ($c_covered / $c_instrumented) * 100}")
    fi
    
    # Output row with 6 columns
    printf "%-37s %10s %12s %10s %10s %12s %10s\n" \
        "$file_path" \
        "$(printf "%'d" "$u_covered")" \
        "$(printf "%'d" "$u_instrumented")" \
        "${u_percentage}%" \
        "$(printf "%'d" "$c_covered")" \
        "$(printf "%'d" "$c_instrumented")" \
        "${c_percentage}%"
done

# Print summary
echo ""
printf "%-37s %10s %12s %10s %10s %12s %10s\n" "$(printf '%0.s=' {1..37})" "$(printf '%0.s=' {1..10})" "$(printf '%0.s=' {1..12})" "$(printf '%0.s=' {1..10})" "$(printf '%0.s=' {1..10})" "$(printf '%0.s=' {1..12})" "$(printf '%0.s=' {1..10})"

# Calculate totals for summary
unity_total_covered=0
unity_total_instrumented=0
coverage_total_covered=0
coverage_total_instrumented=0

for file_path in "${!all_files[@]}"; do
    unity_total_covered=$((unity_total_covered + "${unity_covered_lines["$file_path"]:-0}"))
    unity_total_instrumented=$((unity_total_instrumented + "${unity_instrumented_lines["$file_path"]:-0}"))
    coverage_total_covered=$((coverage_total_covered + "${coverage_covered_lines["$file_path"]:-0}"))
    coverage_total_instrumented=$((coverage_total_instrumented + "${coverage_instrumented_lines["$file_path"]:-0}"))
done

# Calculate percentages
unity_total_pct="0.000"
if [ "$unity_total_instrumented" -gt 0 ]; then
    unity_total_pct=$(awk "BEGIN {printf \"%.3f\", ($unity_total_covered / $unity_total_instrumented) * 100}")
fi

coverage_total_pct="0.000"
if [ "$coverage_total_instrumented" -gt 0 ]; then
    coverage_total_pct=$(awk "BEGIN {printf \"%.3f\", ($coverage_total_covered / $coverage_total_instrumented) * 100}")
fi

printf "%-37s %10s %12s %10s %10s %12s %10s\n" "TOTAL (${#all_files[@]} files)" \
    "$(printf "%'d" "$unity_total_covered")" \
    "$(printf "%'d" "$unity_total_instrumented")" \
    "${unity_total_pct}%" \
    "$(printf "%'d" "$coverage_total_covered")" \
    "$(printf "%'d" "$coverage_total_instrumented")" \
    "${coverage_total_pct}%"

echo ""
echo "Summary:"
echo "  Unity files analyzed: $unity_files"
echo "  Coverage files analyzed: $coverage_files"
echo "  Total unique files: ${#all_files[@]}"
echo "  Unity coverage: ${unity_total_pct}% ($unity_total_covered/$unity_total_instrumented lines)"
echo "  General coverage: ${coverage_total_pct}% ($coverage_total_covered/$coverage_total_instrumented lines)"
