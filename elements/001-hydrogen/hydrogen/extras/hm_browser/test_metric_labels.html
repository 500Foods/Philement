<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hydrogen Metrics Browser - Metric Label Test</title>

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }

    .test-container {
      max-width: 1200px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    .test-section {
      margin-bottom: 20px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
    }

    .test-section h3 {
      margin-top: 0;
      color: #333;
    }

    .test-results {
      background-color: #f9f9f9;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
      font-family: monospace;
      font-size: 14px;
      max-height: 300px;
      overflow-y: auto;
    }

    .success {
      color: green;
    }

    .error {
      color: red;
    }

    .metric-item {
      padding: 8px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
    }

    .metric-path {
      font-family: monospace;
      font-size: 12px;
      color: #666;
      max-width: 400px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .metric-label {
      font-weight: bold;
      color: #333;
    }

    button {
      background-color: #4a90e2;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-top: 10px;
    }

    button:hover {
      background-color: #3a7bc8;
    }
  </style>
</head>
<body>
  <div class="test-container">
    <h1>Hydrogen Metrics Browser - Enhanced Metric Label Test</h1>

    <div class="test-section">
      <h3>Test Enhanced Metric Extraction</h3>
      <button id="test-metric-extraction">Test Metric Extraction</button>
      <div id="test-results" class="test-results"></div>
    </div>

    <div class="test-section">
      <h3>Test Data Value Lookup</h3>
      <button id="test-data-lookup">Test Data Value Lookup</button>
      <div id="lookup-results" class="test-results"></div>
    </div>
  </div>

  <script>
    // Mock data similar to the actual metrics structure
    const mockMetricsData = {
      summary: {
        total_tests: 1241,
        combined_coverage: 80.72
      },
      test_results: {
        data: [
          {
            test_id: "01-CMP",
            tests: 19,
            pass: 19,
            fail: 0,
            elapsed: 8.303
          },
          {
            test_id: "02-ENV",
            tests: 9,
            pass: 9,
            fail: 0,
            elapsed: 0.338
          }
        ]
      },
      cloc: {
        main: [
          {
            language: "Test C/Headers",
            files: 656,
            code: 84233,
            comment: 23723
          },
          {
            language: "Core C/Headers",
            files: 371,
            code: 44221,
            comment: 15691
          }
        ]
      },
      coverage: {
        data: [
          {
            file_path: "{CYAN}api/api_service.c{RESET}",
            coverage_percentage: 66.197
          },
          {
            file_path: "{GREEN}database/database.c{RESET}",
            coverage_percentage: 62.016
          }
        ]
      }
    };

    document.getElementById('test-metric-extraction').addEventListener('click', function() {
      const resultsDiv = document.getElementById('test-results');
      resultsDiv.innerHTML = 'Testing enhanced metric extraction...<br>';

      try {
        // Test the enhanced metric extraction
        const metrics = HMB.extractNumericValues(mockMetricsData);

        if (metrics && metrics.length > 0) {
          resultsDiv.innerHTML += `<span class="success">✓ Extracted ${metrics.length} metrics</span><br><br>`;

          // Show some sample metrics
          resultsDiv.innerHTML += '<strong>Sample Metrics:</strong><br>';

          // Show test_results metrics
          const testMetrics = metrics.filter(m => m.path.includes('test_results'));
          if (testMetrics.length > 0) {
            resultsDiv.innerHTML += '<br><strong>Test Results Metrics:</strong><br>';
            testMetrics.slice(0, 4).forEach(metric => {
              resultsDiv.innerHTML += `
                <div class="metric-item">
                  <span class="metric-label">${metric.label}</span>
                  <span class="metric-path">${metric.path}</span>
                  <span>${metric.value}</span>
                </div>
              `;
            });
          }

          // Show cloc metrics
          const clocMetrics = metrics.filter(m => m.path.includes('cloc'));
          if (clocMetrics.length > 0) {
            resultsDiv.innerHTML += '<br><strong>CLOC Metrics:</strong><br>';
            clocMetrics.slice(0, 4).forEach(metric => {
              resultsDiv.innerHTML += `
                <div class="metric-item">
                  <span class="metric-label">${metric.label}</span>
                  <span class="metric-path">${metric.path}</span>
                  <span>${metric.value}</span>
                </div>
              `;
            });
          }

          // Show coverage metrics
          const coverageMetrics = metrics.filter(m => m.path.includes('coverage'));
          if (coverageMetrics.length > 0) {
            resultsDiv.innerHTML += '<br><strong>Coverage Metrics:</strong><br>';
            coverageMetrics.slice(0, 4).forEach(metric => {
              resultsDiv.innerHTML += `
                <div class="metric-item">
                  <span class="metric-label">${metric.label}</span>
                  <span class="metric-path">${metric.path}</span>
                  <span>${metric.value}</span>
                </div>
              `;
            });
          }

          resultsDiv.innerHTML += `<br><span class="success">✓ Enhanced metric extraction working correctly</span>`;
        } else {
          resultsDiv.innerHTML += '<span class="error">✗ No metrics extracted</span>';
        }
      } catch (error) {
        resultsDiv.innerHTML += `<span class="error">✗ Error during metric extraction: ${error.message}</span>`;
        console.error('Metric extraction error:', error);
      }
    });

    document.getElementById('test-data-lookup').addEventListener('click', function() {
      const resultsDiv = document.getElementById('lookup-results');
      resultsDiv.innerHTML = 'Testing data value lookup...<br>';

      try {
        // Create a mock metric with our enhanced structure
        const mockMetric = {
          path: 'test_results.data.01-CMP.tests',
          value: 19,
          label: 'Test 01-CMP Tests (01-CMP)',
          originalPath: 'test_results.data[0].tests',
          context: { test_id: '01-CMP' }
        };

        // Add it to the available metrics
        HMB.state = HMB.state || {};
        HMB.state.availableMetrics = [mockMetric];

        // Test data lookup
        const testValue = HMB.getNestedValue(mockMetricsData, mockMetric.path);

        if (testValue !== undefined) {
          resultsDiv.innerHTML += `<span class="success">✓ Found value ${testValue} using enhanced path: ${mockMetric.path}</span><br>`;
          resultsDiv.innerHTML += `<span class="success">✓ Original path lookup working: ${mockMetric.originalPath} -> ${testValue}</span><br>`;
          resultsDiv.innerHTML += `<span class="success">✓ Data value lookup system working correctly</span>`;
        } else {
          resultsDiv.innerHTML += `<span class="error">✗ Could not find value using path: ${mockMetric.path}</span>`;
        }
      } catch (error) {
        resultsDiv.innerHTML += `<span class="error">✗ Error during data lookup: ${error.message}</span>`;
        console.error('Data lookup error:', error);
      }
    });

    // Initialize HMB namespace if not already present
    window.HMB = window.HMB || {
      extractNumericValues: function(data, path = '', context = {}) {
        // Simplified version for testing
        const results = [];

        for (const [key, value] of Object.entries(data)) {
          const newPath = path ? `${path}.${key}` : key;
          const newContext = {...context};

          // Handle test_id context
          if (data.test_id) newContext.test_id = data.test_id;
          if (data.language) newContext.language = data.language;
          if (data.file_path) newContext.file_path = data.file_path;

          if (typeof value === 'number') {
            // Create clean path
            let cleanPath = newPath;
            if (newContext.test_id && newPath.includes('test_results.data')) {
              cleanPath = newPath.replace(/test_results\.data\[\d+\]/, `test_results.data.${newContext.test_id}`);
            } else if (newContext.language && newPath.includes('cloc.main')) {
              cleanPath = newPath.replace(/cloc\.main\[\d+\]/, `cloc.main.${newContext.language.replace(/\s+/g, '_')}`);
            }

            // Create enhanced label
            let label = newPath.replace(/\./g, ' ').replace(/\[/g, ' ').replace(/\]/g, '');
            if (newContext.test_id) {
              label = `Test ${newContext.test_id} ${key} (${newContext.test_id})`;
            } else if (newContext.language) {
              label = `CLOC ${newContext.language} ${key} (${newContext.language})`;
            }

            results.push({
              path: cleanPath,
              value: value,
              label: label,
              originalPath: newPath,
              context: newContext
            });
          }
          else if (Array.isArray(value)) {
            value.forEach((item, index) => {
              if (typeof item === 'object' && item !== null) {
                const arrayContext = {...newContext};
                if (item.test_id) arrayContext.test_id = item.test_id;
                if (item.language) arrayContext.language = item.language;
                if (item.file_path) arrayContext.file_path = item.file_path;

                results.push(...this.extractNumericValues(item, `${newPath}[${index}]`, arrayContext));
              }
            });
          }
          else if (typeof value === 'object' && value !== null) {
            results.push(...this.extractNumericValues(value, newPath, newContext));
          }
        }

        return results;
      },

      getNestedValue: function(obj, path) {
        // Try to find metric in available metrics first
        if (this.state && this.state.availableMetrics) {
          const metric = this.state.availableMetrics.find(m => m.path === path);
          if (metric && metric.originalPath) {
            return this.getNestedValueByPath(obj, metric.originalPath);
          }
        }

        // Fallback to direct path
        return this.getNestedValueByPath(obj, path);
      },

      getNestedValueByPath: function(obj, path) {
        return path.split('.').reduce((o, p) => {
          if (p.includes('[')) {
            const arrayPart = p.match(/^([^\[]+)\[(\d+)\]/);
            if (arrayPart) {
              const arrayName = arrayPart[1];
              const index = parseInt(arrayPart[2]);
              return (o || {})[arrayName] ? (o || {})[arrayName][index] : undefined;
            }
          }
          return (o || {})[p];
        }, obj);
      }
    };
  </script>
</body>
</html>