e#!/bin/bash

# Script: analyze-gcov-coverage.sh
# Purpose: Analyze gcov files to show detailed line-by-line coverage statistics
# Usage: ./analyze-gcov-coverage.sh
# 
# This script analyzes gcov files generated by Test 11 Unity tests and provides
# detailed coverage information focusing on the Unity test coverage data.

# Get script directory and project paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
BUILD_DIR="$PROJECT_ROOT/build/unity/src"

# Load .trial-ignore patterns for consistent filtering
TRIAL_IGNORE_PATTERNS=()
if [[ -f "$PROJECT_ROOT/.trial-ignore" ]]; then
    while IFS= read -r line; do
        # Skip comments and empty lines
        if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]; then
            continue
        fi
        # Remove leading ./ if present and add pattern
        pattern="${line#./}"
        TRIAL_IGNORE_PATTERNS+=("$pattern")
    done < "$PROJECT_ROOT/.trial-ignore"
fi

# Function to check if a file should be ignored based on .trial-ignore
should_ignore_file() {
    local filename="$1"
    
    for pattern in "${TRIAL_IGNORE_PATTERNS[@]}"; do
        if [[ "$filename" == *"$pattern"* ]]; then
            return 0  # Should ignore
        fi
    done
    
    return 1  # Should not ignore
}

# Initialize counters
total_covered_lines=0
total_instrumented_lines=0
total_files=0

# Function to analyze a single gcov file
analyze_gcov_file() {
    local gcov_file="$1"
    local covered_lines=0
    local instrumented_lines=0
    
    # Parse the gcov file
    while IFS= read -r line; do
        # Skip metadata lines (starting with spaces and dash)
        if [[ "$line" =~ ^[[:space:]]*-:[[:space:]]*[0-9]+: ]]; then
            continue
        fi
        
        # Count covered lines (lines with execution count)
        if [[ "$line" =~ ^[[:space:]]*[0-9]+:[[:space:]]*[0-9]+: ]]; then
            ((covered_lines++))
            ((instrumented_lines++))
        # Count uncovered but instrumented lines
        elif [[ "$line" =~ ^[[:space:]]*#####:[[:space:]]*[0-9]+: ]]; then
            ((instrumented_lines++))
        fi
    done < "$gcov_file"
    
    # Skip files with no instrumented lines
    if [ $instrumented_lines -eq 0 ]; then
        return
    fi
    
    # Calculate coverage ratio
    local coverage_ratio="0.000"
    if [ $instrumented_lines -gt 0 ]; then
        coverage_ratio=$(awk "BEGIN {printf \"%.3f\", ($covered_lines / $instrumented_lines) * 100}")
    fi
    
    # Clean up the path for display - show as src/filename
    local filename_only=$(basename "$gcov_file" .gcov)
    local display_path="src/$filename_only"
    
    # Output formatted line: filename, covered, instrumented, ratio
    printf "%-37s %10s %12s %10s\n" \
        "$display_path" \
        "$(printf "%'d" $covered_lines)" \
        "$(printf "%'d" $instrumented_lines)" \
        "${coverage_ratio}%"
    
    # Add to totals
    total_covered_lines=$((total_covered_lines + covered_lines))
    total_instrumented_lines=$((total_instrumented_lines + instrumented_lines))
    total_files=$((total_files + 1))
}

# Print header
echo "GCOV Coverage Analysis Report"
echo "Generated: $(date)"
echo "Project: $(basename "$PROJECT_ROOT")"
echo ""
echo "Coverage statistics from Unity test gcov files"
echo ""
printf "%-37s %10s %12s %10s\n" "File Path" "Covered" "Instrumented" "Coverage"
printf "%-37s %10s %12s %10s\n" "$(printf '%0.s-' {1..37})" "$(printf '%0.s-' {1..10})" "$(printf '%0.s-' {1..12})" "$(printf '%0.s-' {1..10})"

# Find and analyze gcov files from the build directory
gcov_files_found=0

# Collect all valid gcov files first, then sort and process them
declare -a valid_gcov_files=()

if [ -d "$BUILD_DIR" ]; then
    while IFS= read -r -d '' gcov_file; do
        # Extract the source filename from the gcov file
        filename=$(basename "$gcov_file" .gcov)
        
        # Skip external libraries and test framework files
        if [[ "$filename" == "unity.c" ]] || \
           [[ "$filename" == "jansson"* ]] || \
           [[ "$filename" == "test_"* ]] || \
           [[ "$gcov_file" == *"/usr/include/"* ]]; then
            continue
        fi
        
        # Skip files that should be ignored based on .trial-ignore
        if should_ignore_file "$filename"; then
            continue
        fi
        
        valid_gcov_files+=("$gcov_file")
    done < <(find "$BUILD_DIR" -name "*.gcov" -type f -print0 2>/dev/null)
    
    # Sort the valid gcov files by filename and process them
    IFS=$'\n' sorted_files=($(sort <<<"${valid_gcov_files[*]}"))
    unset IFS
    
    for gcov_file in "${sorted_files[@]}"; do
        analyze_gcov_file "$gcov_file"
        ((gcov_files_found++))
    done
fi

# Print summary
echo ""
printf "%-37s %10s %12s %10s\n" "$(printf '%0.s=' {1..37})" "$(printf '%0.s=' {1..10})" "$(printf '%0.s=' {1..12})" "$(printf '%0.s=' {1..10})"

# Calculate overall coverage percentage
overall_coverage="0.000"
if [ $total_instrumented_lines -gt 0 ]; then
    overall_coverage=$(awk "BEGIN {printf \"%.3f\", ($total_covered_lines / $total_instrumented_lines) * 100}")
fi

printf "%-37s %10s %12s %10s\n" "TOTAL ($total_files files)" \
    "$(printf "%'d" $total_covered_lines)" \
    "$(printf "%'d" $total_instrumented_lines)" \
    "${overall_coverage}%"

echo ""
echo "Summary:"
echo "  Files analyzed: $gcov_files_found"
echo "  Total covered lines: $(printf "%'d" $total_covered_lines)"
echo "  Total instrumented lines: $(printf "%'d" $total_instrumented_lines)"
echo "  Overall coverage: ${overall_coverage}%"
