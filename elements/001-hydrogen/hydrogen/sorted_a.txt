151:            add_launch_message(&messages, &count, &capacity, strdup("  No-Go:   No IPv4 interfaces available"));
152:            ready = false;
158:            add_launch_message(&messages, &count, &capacity, strdup("  No-Go:   No IPv6 interfaces available"));
159:            ready = false;
247:    log_this(SR_WEBSERVER, "    System state verified", LOG_LEVEL_DEBUG, 0);
250:    log_this(SR_WEBSERVER, "Initializing web server", LOG_LEVEL_DEBUG, 0);
252:    if (!init_web_server(&app_config->webserver)) {
253:        log_this(SR_WEBSERVER, "Failed to initialize web server", LOG_LEVEL_ERROR, 0);
254:        log_this(SR_WEBSERVER, "LAUNCH: " SR_WEBSERVER " Failed to initialize", LOG_LEVEL_DEBUG, 0);
255:        return 0;
259:    log_this(SR_WEBSERVER, "Verifying configuration", LOG_LEVEL_DEBUG, 0);
260:    log_this(SR_WEBSERVER, "― IPv6 support: %s", LOG_LEVEL_DEBUG, 1, app_config->webserver.enable_ipv6 ? "enabled" : "disabled");
261:    log_this(SR_WEBSERVER, "― Port: %d", LOG_LEVEL_DEBUG, 1, app_config->webserver.port);
262:    log_this(SR_WEBSERVER, "― WebRoot: %s", LOG_LEVEL_DEBUG, 1, app_config->webserver.web_root);
263:    log_this(SR_WEBSERVER, "― Upload Path: %s", LOG_LEVEL_DEBUG, 1, app_config->webserver.upload_path);
264:    log_this(SR_WEBSERVER, "― Upload Dir: %s", LOG_LEVEL_DEBUG, 1, app_config->webserver.upload_dir);
265:    log_this(SR_WEBSERVER, "― Thread Pool Size: %d", LOG_LEVEL_DEBUG, 1, app_config->webserver.thread_pool_size);
266:    log_this(SR_WEBSERVER, "― Max Connections: %d", LOG_LEVEL_DEBUG, 1, app_config->webserver.max_connections);
267:    log_this(SR_WEBSERVER, "― Max Connections Per IP: %d", LOG_LEVEL_DEBUG, 1, app_config->webserver.max_connections_per_ip);
268:    log_this(SR_WEBSERVER, "― Connection Timeout: %d seconds", LOG_LEVEL_DEBUG, 1, app_config->webserver.connection_timeout);
271:    log_this(SR_WEBSERVER, "Creating web server thread", LOG_LEVEL_DEBUG, 0);
273:    pthread_attr_init(&thread_attr);
274:    pthread_attr_setdetachstate(&thread_attr, PTHREAD_CREATE_JOINABLE);
276:    if (pthread_create(&webserver_thread, &thread_attr, run_web_server, NULL) != 0) {
277:        log_this(SR_WEBSERVER, "Failed to start web server thread", LOG_LEVEL_TRACE, 0);
278:        pthread_attr_destroy(&thread_attr);
279:        shutdown_web_server();
280:        return 0;
282:    pthread_attr_destroy(&thread_attr);
285:    add_service_thread(&webserver_threads, webserver_thread);
288:    int max_tries = 10000; // 10 seconds total
289:    int tries = 0;
290:    bool server_ready = false;
292:    log_this(SR_WEBSERVER, "Waiting for initialization", LOG_LEVEL_DEBUG, 0);
295:    if (webserver_daemon != NULL) {
296:        const union MHD_DaemonInfo *info = MHD_get_daemon_info(webserver_daemon, MHD_DAEMON_INFO_BIND_PORT);
297:        if (info != NULL && info->port > 0) {
298:            server_ready = true;
303:    while (!server_ready && tries < 100) {
304:        sched_yield(); // Yield CPU to other threads
307:        if (webserver_daemon != NULL) {
308:            const union MHD_DaemonInfo *info = MHD_get_daemon_info(webserver_daemon, MHD_DAEMON_INFO_BIND_PORT);
309:            if (info != NULL && info->port > 0) {
311:                const union MHD_DaemonInfo *conn_info = MHD_get_daemon_info(webserver_daemon, MHD_DAEMON_INFO_CURRENT_CONNECTIONS);
312:                unsigned int num_connections = conn_info ? conn_info->num_connections : 0;
315:                const union MHD_DaemonInfo *thread_info = MHD_get_daemon_info(webserver_daemon, MHD_DAEMON_INFO_FLAGS);
316:                bool using_threads = thread_info && (thread_info->flags & MHD_USE_THREAD_PER_CONNECTION);
318:                log_this(SR_WEBSERVER, "Server status:", LOG_LEVEL_DEBUG, 0);
319:                log_this(SR_WEBSERVER, "― Bound to port: %u", LOG_LEVEL_DEBUG, 1, info->port);
320:                log_this(SR_WEBSERVER, "― Active connections: %u", LOG_LEVEL_DEBUG, 1, num_connections);
321:                log_this(SR_WEBSERVER, "― Thread mode: %s", LOG_LEVEL_DEBUG, 1, using_threads ? "Thread per connection" : "Single thread");
322:                log_this(SR_WEBSERVER, "― IPv6: %s", LOG_LEVEL_DEBUG, 1, app_config->webserver.enable_ipv6 ? "enabled" : "disabled");
323:                log_this(SR_WEBSERVER, "― Max connections: %d", LOG_LEVEL_DEBUG, 1, app_config->webserver.max_connections);
326:                log_this(SR_WEBSERVER, "― Network interfaces:", LOG_LEVEL_DEBUG, 0);
328:                if (getifaddrs(&ifaddr) != -1) {
329:                    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
330:                        if (ifa->ifa_addr == NULL)
331:                            continue;
333:                        int family = ifa->ifa_addr->sa_family;
334:                        if (family == AF_INET || (family == AF_INET6 && app_config->webserver.enable_ipv6)) {
336:                            int s = getnameinfo(ifa->ifa_addr,
341:                            if (s == 0) {
342:                                log_this(SR_WEBSERVER, "――― %s: %s (%s)", LOG_LEVEL_DEBUG, 3,
349:                    freeifaddrs(ifaddr);
352:                server_ready = true;
353:                break;
356:        tries++;
360:    struct timespec micro_wait = {0, 10000}; // 10 microseconds
361:    while (!server_ready && tries < 1000) {
362:        nanosleep(&micro_wait, NULL);
365:        if (webserver_daemon != NULL) {
366:            const union MHD_DaemonInfo *info = MHD_get_daemon_info(webserver_daemon, MHD_DAEMON_INFO_BIND_PORT);
367:            if (info != NULL && info->port > 0) {
369:                const union MHD_DaemonInfo *conn_info = MHD_get_daemon_info(webserver_daemon, MHD_DAEMON_INFO_CURRENT_CONNECTIONS);
370:                unsigned int num_connections = conn_info ? conn_info->num_connections : 0;
373:                const union MHD_DaemonInfo *thread_info = MHD_get_daemon_info(webserver_daemon, MHD_DAEMON_INFO_FLAGS);
374:                bool using_threads = thread_info && (thread_info->flags & MHD_USE_THREAD_PER_CONNECTION);
376:                log_this(SR_WEBSERVER, "Server status:", LOG_LEVEL_DEBUG, 0);
377:                log_this(SR_WEBSERVER, "― Bound to port: %u", LOG_LEVEL_DEBUG, 1, info->port);
378:                log_this(SR_WEBSERVER, "― Active connections: %u", LOG_LEVEL_DEBUG, 1, num_connections);
379:                log_this(SR_WEBSERVER, "― Thread mode: %s", LOG_LEVEL_DEBUG, 1, using_threads ? "Thread per connection" : "Single thread");
380:                log_this(SR_WEBSERVER, "― IPv6: %s", LOG_LEVEL_DEBUG, 1, app_config->webserver.enable_ipv6 ? "enabled" : "disabled");
381:                log_this(SR_WEBSERVER, "― Max connections: %d", LOG_LEVEL_DEBUG, 1, app_config->webserver.max_connections);
384:                log_this(SR_WEBSERVER, "― Network interfaces:", LOG_LEVEL_DEBUG, 0);
386:                if (getifaddrs(&ifaddr) != -1) {
387:                    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
388:                        if (ifa->ifa_addr == NULL)
389:                            continue;
391:                        int family = ifa->ifa_addr->sa_family;
392:                        if (family == AF_INET || (family == AF_INET6 && app_config->webserver.enable_ipv6)) {
394:                            int s = getnameinfo(ifa->ifa_addr,
399:                            if (s == 0) {
400:                                log_this(SR_WEBSERVER, "――― %s: %s (%s)", LOG_LEVEL_DEBUG, 3,
407:                    freeifaddrs(ifaddr);
410:                server_ready = true;
411:                break;
414:        tries++;
418:    struct timespec milli_wait = {0, 1000000}; // 1ms
419:    while (!server_ready && tries < max_tries) {
420:        nanosleep(&milli_wait, NULL);
423:        if (webserver_daemon != NULL) {
424:            const union MHD_DaemonInfo *info = MHD_get_daemon_info(webserver_daemon, MHD_DAEMON_INFO_BIND_PORT);
425:            if (info != NULL && info->port > 0) {
427:                const union MHD_DaemonInfo *conn_info = MHD_get_daemon_info(webserver_daemon, MHD_DAEMON_INFO_CURRENT_CONNECTIONS);
428:                unsigned int num_connections = conn_info ? conn_info->num_connections : 0;
431:                const union MHD_DaemonInfo *thread_info = MHD_get_daemon_info(webserver_daemon, MHD_DAEMON_INFO_FLAGS);
432:                bool using_threads = thread_info && (thread_info->flags & MHD_USE_THREAD_PER_CONNECTION);
434:                log_this(SR_WEBSERVER, "Server status:", LOG_LEVEL_DEBUG, 0);
435:                log_this(SR_WEBSERVER, "― Bound to port: %u", LOG_LEVEL_DEBUG, 1, info->port);
436:                log_this(SR_WEBSERVER, "― Active connections: %u", LOG_LEVEL_DEBUG, 1, num_connections);
437:                log_this(SR_WEBSERVER, "― Thread mode: %s", LOG_LEVEL_DEBUG, 1, using_threads ? "Thread per connection" : "Single thread");
438:                log_this(SR_WEBSERVER, "― IPv6: %s", LOG_LEVEL_DEBUG, 1, app_config->webserver.enable_ipv6 ? "enabled" : "disabled");
439:                log_this(SR_WEBSERVER, "― Max connections: %d", LOG_LEVEL_DEBUG, 1, app_config->webserver.max_connections);
442:                log_this(SR_WEBSERVER, "― Network interfaces:", LOG_LEVEL_DEBUG, 0);
444:                if (getifaddrs(&ifaddr) != -1) {
445:                    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
446:                        if (ifa->ifa_addr == NULL)
447:                            continue;
449:                        int family = ifa->ifa_addr->sa_family;
450:                        if (family == AF_INET || (family == AF_INET6 && app_config->webserver.enable_ipv6)) {
452:                            int s = getnameinfo(ifa->ifa_addr,
457:                            if (s == 0) {
458:                                log_this(SR_WEBSERVER, "――― %s: %s (%s)", LOG_LEVEL_DEBUG, 3,
465:                    freeifaddrs(ifaddr);
468:                server_ready = true;
469:                break;
472:        tries++;
474:        if (tries % 1000 == 0) { // Log every second
475:            log_this(SR_WEBSERVER, "Still waiting for web server... (%d seconds)", LOG_LEVEL_DEBUG, 1, tries / 1000);
479:    if (!server_ready) {
480:        log_this(SR_WEBSERVER, "Web server failed to start within timeout", LOG_LEVEL_ERROR, 0);
481:        shutdown_web_server();
482:        return 0;
486:    log_this(SR_WEBSERVER, "Updating " SR_WEBSERVER " in " SR_REGISTRY, LOG_LEVEL_DEBUG, 0);
487:    update_subsystem_on_startup(SR_WEBSERVER, true);
489:    SubsystemState final_state = get_subsystem_state(webserver_subsystem_id);
490:    if (final_state == SUBSYSTEM_RUNNING) {
491:        log_this(SR_WEBSERVER, "LAUNCH: " SR_WEBSERVER " COMPLETE", LOG_LEVEL_DEBUG, 0);
493:        log_this(SR_WEBSERVER, "LAUNCH: " SR_WEBSERVER " Warning: Unexpected final state: %s", LOG_LEVEL_DEBUG, 1, subsystem_state_to_string(final_state));
494:        return 0;
496:    return 1;
77:            add_launch_message(&messages, &count, &capacity, strdup("  No-Go:   Failed to register Threads dependency"));
78:            finalize_launch_messages(&messages, &count, &capacity);
79:            return (LaunchReadiness){ .subsystem = SR_WEBSERVER, .ready = false, .messages = messages };
84:            add_launch_message(&messages, &count, &capacity, strdup("  No-Go:   Failed to register Network dependency"));
85:            finalize_launch_messages(&messages, &count, &capacity);
86:            return (LaunchReadiness){ .subsystem = SR_WEBSERVER, .ready = false, .messages = messages };
